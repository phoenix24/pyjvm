from enum import Enum
from typing import Mapping, List, Set


class PyVMType(Enum):
    Z = 0
    B = 1
    S = 2
    C = 3
    I = 5
    J = 6
    F = 7
    D = 8
    A = 9


class PyVMValue(object):
    def __init__(self, type: PyVMType, value: int):
        self.type = type
        self.value = value
    
    def copy(self):
        return PyVMValue(self.type, self.value)

    @staticmethod
    def pyref(value: int):
        return PyVMValue(PyVMType.A, value)

    @staticmethod
    def pyint(value: int):
        return PyVMValue(PyVMType.I, value)

    @staticmethod
    def pydouble(value: float):
        return PyVMValue(PyVMType.D, value)

    def __str__(self):
        return "PyVMValue(type={}, value={})".format(self.type, self.value)


class PyKonst(object):
    ACC_PUBLIC = 0x0001       # Declared public; may be accessed from outside its package.
    ACC_PRIVATE = 0x0002      # Declared private; usable only within the defining class.
    ACC_PROTECTED = 0x0004    # Declared protected; may be accessed within subclasses.
    ACC_STATIC = 0x0008       # Declared static
    ACC_FINAL = 0x0010        # Declared final; no subclasses allowed.
    ACC_SUPER = 0x0020        # (Class) Treat superclass methods specially when invoked by the invokespecial instruction.
    ACC_VOLATILE = 0x0040     # (Field) Declared volatile; cannot be cached.
    ACC_TRANSIENT = 0x0080    # (Field) Declared transient; not written or read by a persistent object manager.
    ACC_INTERFACE = 0x0200    # (Class) Is an interface, not a class.
    ACC_ABSTRACT = 0x0400     # (Class) Declared abstract; must not be instantiated.
    ACC_SYNTHETIC = 0x1000    # Declared synthetic; not present in the source code.
    ACC_ANNOTATION = 0x2000   # Declared as an annotation type.
    ACC_ENUM = 0x4000         # Declared as an enum type.

    # method only constants
    ACC_SYNCHRONIZED = 0x0020 # (Method) Declared synchronized; invocation is wrapped by a monitor use.
    ACC_BRIDGE = 0x0040       # (Method) A bridge, generated by the compiler.
    ACC_VARARGS = 0x0080      # (Method) Declared with variable number of arguments.
    ACC_NATIVE = 0x0100       # (Method) Declared native; implemented in a language other than Java.
    ACC_ABSTRACT_M = 0x0400   # (Method) Declared abstract; no implementation is provided.
    ACC_STRICT = 0x0800       # (Method) Declared strictfp; floating-point mode is FP-strict.


class PyRtKlass(object):
    def __init__(self, klass: str, super: str):
        self.name = klass
        self.super = super

        self.items = {}
        self.klassByIndex = {}

        self.fields = {}
        self.fieldsByIndex = {}
        self.orderedFields = []
        self.staticFieldByName = {}

        self.methods = {}
        self.methodsByIndex = {}

    def add_defined_method(self, method):
        self.methods.update({method.name_type: method})

    def add_defined_field(self, field):
        self.fields.update({field.name: field})

    def add_field(self, field):
        self.fields.update({field.name: field})
        if field.flags & PyKonst.ACC_STATIC:
            self.staticFieldByName.update({field.name: None})
        else:
            self.orderedFields.append(field)

    def add_klass_ref(self, index: int, name: str):
        self.klassByIndex.update({index: name})

    def add_field_ref(self, index: int, name: str):
        self.fieldsByIndex.update(({index: name}))

    def add_method_ref(self, index: int, name: str):
        self.methodsByIndex.update({index: name})

    def get_fields(self) -> List[str]:
        return list(self.fields.keys())

    def get_method(self, name: str) -> List[bytes]:
        return self.methods[name]

    def get_methods(self) -> List[str]:
        return list(self.methods.keys())

    def get_method_by_idx(self, index: int):
        return self.methodsByIndex[index]


class PyRtField(object):
    def __init__(self, klass: PyRtKlass, name: str, type, flags: int):
        self.name = name
        self.type = type
        self.klass = klass
        self.flags = flags


class PyRtMethod(object):
    def __init__(self, klass: PyRtKlass, signature, name_type: str, bytecode, flags: int):
        self.klass = klass
        self.flags = flags
        self.bytecode = bytecode
        self.signature = signature
        self.name_type = name_type

    def is_static(self) -> bool:
        return not not (self.flags & PyKonst.ACC_STATIC)


