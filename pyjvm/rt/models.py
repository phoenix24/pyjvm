from enum import Enum
from typing import Mapping, List, Set


class PyVMType(Enum):
    Z = 0
    B = 1
    S = 2
    C = 3
    I = 5
    J = 6
    F = 7
    D = 8
    A = 9


class PyVMValue(object):
    def __init__(self, type: PyVMType, value: int):
        self.type = type
        self.value = value
    
    def copy(self, value=None, type=None):
        type = type or self.type
        value = value or self.value
        return PyVMValue(type, value)

    def clone(self):
        return PyVMValue(self.type, self.value)

    @staticmethod
    def pyref(value: int):
        return PyVMValue(PyVMType.A, value)

    @staticmethod
    def pyint(value: int):
        return PyVMValue(PyVMType.I, value)

    @staticmethod
    def pydouble(value: float):
        return PyVMValue(PyVMType.D, value)

    def __type__(self, other: 'PyVMValue'):
        return isinstance(other, PyVMValue) \
            and self.type == other.type

    def __or__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value | other.value
        return self.copy(value=value)

    def __and__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value & other.value
        return self.copy(value=value)

    def __neg__(self) -> 'PyVMValue':
        value = -1 * self.value
        return self.copy(value=value)

    def __add__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value + other.value
        return self.copy(value=value)

    def __sub__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value - other.value
        return self.copy(value=value)

    def __mul__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value * other.value
        return self.copy(value=value)

    def __mod__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value % other.value
        return self.copy(value=value)

    def __truediv__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value / other.value
        return self.copy(value=value)

    def __floordiv__(self, other: 'PyVMValue') -> 'PyVMValue':
        value = self.value // other.value
        return self.copy(value=value)

    def __eq__(self, other: 'PyVMValue') -> bool:
        return self.__type__(other) \
            and self.value == other.value

    def __ne__(self, other: 'PyVMValue'):
        return not self.__eq__(other)

    def __lt__(self, other: 'PyVMValue'):
        return self.__type__(other) \
            and self.value < other.value

    def __le__(self, other: 'PyVMValue'):
        return self.__type__(other) \
            and self.value <= other.value

    def __gt__(self, other: 'PyVMValue'):
        return self.__type__(other) \
            and self.value > other.value

    def __ge__(self, other: 'PyVMValue'):
        return self.__type__(other) \
            and self.value >= other.value

    def __str__(self):
        return "PyVMValue(type={}, value={})".format(self.type, self.value)

    def __repr__(self):
        return self.__str__()


class PyVMKonst(object):
    ACC_PUBLIC = 0x0001       # Declared public; may be accessed from outside its package.
    ACC_PRIVATE = 0x0002      # Declared private; usable only within the defining class.
    ACC_PROTECTED = 0x0004    # Declared protected; may be accessed within subclasses.
    ACC_STATIC = 0x0008       # Declared static
    ACC_FINAL = 0x0010        # Declared final; no subclasses allowed.
    ACC_SUPER = 0x0020        # (Class) Treat superclass methods specially when invoked by the invokespecial instruction.
    ACC_VOLATILE = 0x0040     # (Field) Declared volatile; cannot be cached.
    ACC_TRANSIENT = 0x0080    # (Field) Declared transient; not written or read by a persistent object manager.
    ACC_INTERFACE = 0x0200    # (Class) Is an interface, not a class.
    ACC_ABSTRACT = 0x0400     # (Class) Declared abstract; must not be instantiated.
    ACC_SYNTHETIC = 0x1000    # Declared synthetic; not present in the source code.
    ACC_ANNOTATION = 0x2000   # Declared as an annotation type.
    ACC_ENUM = 0x4000         # Declared as an enum type.

    # method only constants
    ACC_SYNCHRONIZED = 0x0020 # (Method) Declared synchronized; invocation is wrapped by a monitor use.
    ACC_BRIDGE = 0x0040       # (Method) A bridge, generated by the compiler.
    ACC_VARARGS = 0x0080      # (Method) Declared with variable number of arguments.
    ACC_NATIVE = 0x0100       # (Method) Declared native; implemented in a language other than Java.
    ACC_ABSTRACT_M = 0x0400   # (Method) Declared abstract; no implementation is provided.
    ACC_STRICT = 0x0800       # (Method) Declared strictfp; floating-point mode is FP-strict.


class PyVMKlass(object):
    def __init__(self, klass: str, super: str):
        self.name = klass
        self.super = super

        self.items = {}
        self.klassByIndex = {}

        self.fields = {}
        self.fieldsByIndex = {}
        self.orderedFields = []
        self.staticFieldByName = {}

        self.methods = {}
        self.methodsByIndex = {}

    def add_defined_method(self, method: 'PyVMMethod') -> None:
        self.methods.update({method.name_type: method})

    def add_defined_field(self, field) -> None:
        self.fields.update({field.name: field})

    def add_field(self, field: 'PyVMField') -> None:
        self.fields.update({field.name: field})
        if field.flags & PyVMKonst.ACC_STATIC:
            self.staticFieldByName.update({field.name: None})
        else:
            self.orderedFields.append(field)

    def add_klass_ref(self, index: int, name: str) -> None:
        self.klassByIndex.update({index: name})

    def add_field_ref(self, index: int, name: str) -> None:
        self.fieldsByIndex.update(({index: name}))

    def add_method_ref(self, index: int, name: str) -> None:
        self.methodsByIndex.update({index: name})

    def get_fields(self) -> List[str]:
        return list(self.fields.keys())

    def get_method(self, name: str) -> 'PyVMMethod':
        return self.methods[name]

    def get_methods(self) -> List[str]:
        return list(self.methods.keys())

    def get_method_by_idx(self, index: int) -> 'PyVMMethod':
        return self.methodsByIndex[index]


class PyVMField(object):
    def __init__(self, klass: PyVMKlass, name: str, type, flags: int):
        self.name = name
        self.type = type
        self.klass = klass
        self.flags = flags


class PyVMMethod(object):
    def __init__(self, klass: PyVMKlass, signature, name_type: str, bytecode, flags: int):
        self.klass = klass
        self.flags = flags
        self.bytecode = bytecode
        self.signature = signature
        self.name_type = name_type
        self.func_params = -1

    def is_static(self) -> bool:
        return not not (self.flags & PyVMKonst.ACC_STATIC)

    @property
    def num_params(self) -> int:
        if self.func_params > -1:
            return self.func_params

        index, self.func_params = 0, 0
        while index < len(self.signature):
            char = self.signature[index]
            if char in ('Z', 'B', 'S', 'C', 'I', 'J', 'F', 'D'):
                self.func_params += 1
            elif char == ')':
                return self.func_params
            elif char == 'L':
                while self.signature[index] != ';':
                    index += 1
            index += 1

        return self.func_params


